## 상속
> 부모가 자식에게 물려주는 행위
>

→ 중복되는 코드를 줄여 개발 시간 단축 효과

- 클래스 상속
    - ** 상속 받을 수 있는 부모클래스는 단 하나

    ```java
    public class 자식 클래스 extends 부모클래스{
    }
    ```

    - 자식 클래스 생성자 선언 할 때 컴파일 과정에서 부모 생성자 기본생성자를 super()로 자동 호출된다.
    - 만약 부모 클래스에 기본 생성자가 없다면 생성자 선언을 따로 해줘야한다.

    ```java
    //자식 생성자 선언
    public 자식클래스(){
    	super();
    	...
    }
    ```


- 메소드 재정의
    - `메소드 오버라이딩` : 자식 클래스에 맞게 재정의하여 사용
        - 메소드가 오버라이딩 되었다면 해당 부모 메소드는 숨겨지고, 자식 메소드가 우선적으로 사용된다.
            - 주의점
                - 부모 메소드의 선언부(리턴타입, 메소드 이름, 매개변수)와 동일해야 한다.
                - 접근 제한을 더 강하게 오버라이딩할 수  없다(  public→ privarte로 변경 불가)
                - 새로운 예외를  throws할 수 없다.
    - 부모 메소드 호출
        - 자식 메소드에서 부모 메서드를 사용하면서 조금 수정해서 사용할 때 사용
        - 부모 메소드를 재사용함으로써 자식 메소드의 중복 작업 내용 없애는 효과

        ```java
        class Parent{
        	public void method(){
        	//작업처리1
        	}
        }
        
        class Child extends Parent{
        	@Override
        	public void method(){
        		super.method(); //=> 부모 메소드 호출
        		//작업처리2
        	}
        }
        ```


- final
    - final 클래스
        - 최종적인 클래스 ⇒ 더 이상 상속x
        - final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다.

        ```java
        public final class 클래스{…}
        ```

    - final 메소드
        - 최종적인 메소드⇒ 오버라이딩 할 수 없는 메소드가 된다.
        - 부모 클래스에서 상속해서 자식 클래스 선언할때 , final 메소드는 자식 클래스에서 재정의 x

        ```java
        public final 리턴타입 메소드(매개변수,..){...}
        ```


- protected
    - 같은 패키지에서는 default 처럼 접근 가능, 다른 패키지에서는 자식 클래스에서 상속을 통해서만 접근 가능하다.

- 타입변환
    - 자동 타입 변환
        - 자식 → 부모 타입으로 변환

      !<img width="350" height="119" alt="Image" src="https://github.com/user-attachments/assets/f6980788-8f9d-46ae-b7ed-3462af2a4ae3" />

        - 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다.

        ```java
        Cat cat = new Cat();
        Animal animal = cat;
        
        - cat 과 animal 변수는 타입만 다를 뿐, 동일한 Cat 객체를 참조한다.
        => Animal amimal = new Cat(); 도 가능
        ```

      !<img width="403" height="173" alt="Image" src="https://github.com/user-attachments/assets/81141c84-c4c5-4cac-9e63-3f21bf466a8b" />

        - 바로 위 부모가 아니더라도 상속 계층에서 상위 타입이면 자동 타입 변환 가능
        - `주의` :  부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만  접근 가능
            - 그러나 자식 클래스에서 오버라이딩된 메소드가 있다면 부모 메소드 대신 오버라이딩 된 메소드가 호출(다형성 때문)
    - 강제 타입 변환
        - 부모→ 자식 타입으로 변환

      !<img width="401" height="138" alt="Image" src="https://github.com/user-attachments/assets/24e36f5a-53d3-4df5-ae33-b0c0fc980928" />

        - 자식 객체가 부모 타입으로 자동 변환된 후 다시 자식 타입으로 변환할 때 강제 타입 변환 사용

- 다형성

  > 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질
  >
    - 필드 다형성 : 필드 타입은 동일하지만(사용 방법 =), 대입되는 객체가 달라져서 실행결과 달라지는것
        - 자식 클래스에서 부모 클래스에서 정의한 메소드를 재정의할 경우
    - 매개변수 다형성
        - 부모 클래스를 매개변수로 가지는 메소드를 호출할때 자식변수를 매개변수로 주어 해당 메소드를 자동 타입 변환을 사용하여 리턴 하게 할 수 있다.

- 객체 타입 확인(`instanceof`)
    - 매개변수의 다형성에서 실제로 어떤 객체가 매개값으로 제공되었는지 확인하는 방법
    - 매개변수가 아니더라도 `변수가 참조하는 객체의 타입 확인하고자 할때`

    ```java
    boolean result = 객체 instanceof 타입; 
    ```

    - java 12 부터 instanceof 연산 결과가 true 일 경우, 우측 타입 변수를 사용할 수 있기 때문에 강제 타입 변환 필요 x

    ```java
    if(parent instanceof Child child){
    	//child 변수 사용
    }
    ```


- 추상 클래스 : 공통된 필드나 메소드를 추출해서 선언한 클래스

  > 추상 클래스는 실체 클래스의 `부모 역할`
  실체 클래스의 공통되는 필드나 메소드를 추출해서 만들었기 때문에 `new 연산자로 직접 사용 x`
  `상속으로만 사용 가능`
  >
    - 추상클래스 선언
        - 클래스 선언 시 `abstract` 키워드 붙이면 됨
        - 자식 객체 생성 시  super()로 추상 클래스의 생성자 호출 되기 때문에 `반드시 생성자 필요`
    - 추상 메소드와 재정의
        - 추상메소드 : 메소드 선언부는 같은데 실행 내용은 자식 클래스마다 다를때

        ```java
        abstract 리턴타입 메소드명(매개변수,...);
        ```

        - 자식 클래스에서 반드시 재정의 해서 실행 내용을 채워야함

- 봉인된 클래스( `sealed` ⇒ java15부터 도입)
    - final 이외에 모든 클래스가 부모 클래스가 될 수 있었으나 java 15부터 무분별한 자식 클래스 생성 방지 위해 봉인된 클래스 도입

    ```java
    public sealed class Person permits Employee,Manager{...}{
    => Person 클래스는 Employee,Manager만 자식 클래스 가능하도록 봉인
    
    - Employee,Manager는 final, non-sealed,sealed 키워드로 선언해야한다.
    ```


